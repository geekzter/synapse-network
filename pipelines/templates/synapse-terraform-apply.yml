# This pipeline template performs a full CI test:
#  - Provision infrastructure
#  - Deploy application
#  - Test application
#  - Destroy infrastructure
parameters:
- name: name
  displayName: Stage Name
  type: string
- name: displayName
  displayName: Stage Display Name
  type: string
- name: inherit
  displayName: Inherit state
  type: boolean
  default: false
- name: provision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: reprovision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: deploy
  displayName: Deploy applications
  type: boolean
  default: true
- name: destroy
  displayName: Destroy infrastructure
  type: string
  default: Always
  values:
  - Always
  - Never 
  - 'On failure'
  - 'On success'
- name: workspace
  displayName: Pipeline Environment / Terraform Workspace
  type: string
  default: ci
  values:
  - ci
  - ci1
  - ci2
  - ci3
  - cd1
  - cd2
  - cd3
  - rel
  - rel1
  - rel2
  - rel3
  - test
  - tst1
  - tst2
  - tst3
- name: deploymentName
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: resourceSuffix
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: unpinTerraform
  displayName: Unpin Terraform version
  type: boolean
  default: false
- name: unpinTerraformProviders
  displayName: Unpin Terraform provider versions
  type: boolean
  default: false
- name: infraArtifactPipeline
  displayName: Pipeline (alias) for artifacts
  type: string
  default: ''
- name: testMode
  displayName: Test Mode (disable most tasks)
  type: boolean
  default: false

stages:
- stage: ${{ parameters.name }}
  displayName: ${{ parameters.displayName }}

  # Global variables shared by all jobs
  variables:
  - name: 'agentTag'
    value: 'web'
  - name: 'artifactName'
    value: 'drop'
  - name: 'TF_WORKSPACE'
    value: ${{ parameters.workspace }}
  - name: 'scriptDirectory'
    ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/scripts'
    ${{ if and(gt(length(parameters.infraArtifactPipeline),0),ne(parameters.infraArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.infraArtifactPipeline}}/$(artifactName)/s/scripts'
    ${{ if eq(parameters.infraArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(artifactName)/s/scripts'
  - name: 'terraformDirectory'
    ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/terraform'
    ${{ if and(gt(length(parameters.infraArtifactPipeline),0),ne(parameters.infraArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.infraArtifactPipeline}}/$(artifactName)/s/terraform'
    ${{ if eq(parameters.infraArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(artifactName)/s/terraform'
  - ${{ if gt(length(parameters.resourceSuffix),0) }}:
    - name: 'TF_VAR_resource_suffix'
      value: ${{ parameters.resourceSuffix }}
  - name: 'resourceGroup' 
    value: 'synapse-network-$(TF_VAR_resource_suffix)'
  - name: 'terraformVersionRequest'
    ${{ if parameters.unpinTerraform }}:
      value: 'latest'
    ${{ if not(parameters.unpinTerraform) }}:
      value: 'preferred'
  - name: cleanUpOnCancel
    ${{ if eq(parameters.destroy, 'Always') }}:
      value: true
    ${{ if eq(parameters.destroy, 'Never') }}:
      value: false
    ${{ if eq(parameters.destroy, 'On failure') }}:
      value: true
    ${{ if eq(parameters.destroy, 'On success') }}:
      value: false
  - name: vmImage
    # value: 'ubuntu-latest'
    value: 'windows-latest' # SqlAzureDacpacDeployment requires Windows

  jobs:
  - job: 'Prepare'
    displayName: 'Prepare'
    condition: succeeded()
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    pool:
      vmImage: '$(vmImage)'

    workspace:
      clean: all

    steps:
      - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
        - download: ${{parameters.infraArtifactPipeline}}
          artifact: $(artifactName)
  
      - pwsh: |
          Write-Host "Script Directory: $(scriptDirectory)"
          Write-Host "Workspace Contents:"
          Get-ChildItem $(Pipeline.Workspace) -Recurse
          Write-Host "Environment:"
          Get-ChildItem -Path Env:* | Sort-Object -Property Name
        displayName: 'Test task'
        enabled: ${{ parameters.testMode }}
      - task: AzureCLI@2
        displayName: 'Gather Terraform settings'
        enabled: ${{ not(parameters.testMode) }}
        name: terraformConfig
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # List environment variables
            Get-ChildItem -Path Env: -Recurse -Include ARM_*,TF_* | Sort-Object -Property Name

            $terraformVersion = (Get-Content .terraform-version)
            Write-Host "##vso[task.setvariable variable=version;isOutput=true]${terraformVersion}"
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'

  - ${{ if or(eq(parameters.provision, true),eq(parameters.reprovision, true),eq(parameters.deploy, true)) }}:
    # Provision on self-hosted agent
    - job: 'Provision'
      dependsOn: 
      - Prepare
      # - CreateEnvironment
      displayName: 'Provision Infrastructure with Terraform'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # We could do this with tfenv, however there is no task for that
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              #(Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          # Name is required so Terraform output exported by tf_deploy.ps1 can be referenced by subsequent Pipeline steps
          # name: terraform
          displayName: 'Terraform init & apply'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              $(scriptDirectory)/tf_deploy.ps1 -init -clear:$${{ not(parameters.inherit) }} -stickysuffix:$${{ parameters.inherit }} -apply -force -trace $(trace) -parallelism $(parallelism)
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(scriptDirectory)'

        - task: AzureCLI@2
          displayName: 'Terraform init'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          displayName: 'Terraform plan'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # Convert uppercased Terraform environment variables to their original casing expeted by Terraform
              foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
                $upperCaseName = $tfvar.Name + "_UC"
                $properCaseName = $tfvar.Name.Substring(0,7) + $tfvar.Name.Substring(7).ToLowerInvariant()
                $null = New-Item -Path env:$upperCaseName -Value $tfVar.Value
                Remove-Item -Path env:$($tfvar.Name)
                $null = New-Item -Path env:$properCaseName -Value $tfVar.Value
                Set-Item -Path env:$upperCaseName -Value $null
              } 
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              # Run Terraform
              terraform version
              terraform plan -out='ci.tfplan'
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          displayName: 'Terraform apply'
          name: terraform
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

              # Run Terraform
              terraform version
              terraform apply -auto-approve 'ci.tfplan'

              # Export Terraform output as task output
              $json = terraform output -json | ConvertFrom-Json -AsHashtable
              foreach ($outputVariable in $json.keys) {
                  $value = $json[$outputVariable].value
                  if ($value) {
                      Write-Host "##vso[task.setvariable variable=$outputVariable;isOutput=true]$value"
                  }
              }              
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

  - ${{ if eq(parameters.reprovision, true) }}:
    # Provision again to test for issue's that only come up when resources already exist 
    - job: 'Reprovision'
      dependsOn:
      - Prepare
      - Provision
      displayName: 'Provision Infrastructure with Terraform (re-entrance test)'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        resourceGroup: $[ dependencies.Provision.outputs['terraform.resource_group_name'] ]
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        # Deallocate/Stop MV's to force tf_deploy.ps1 to test for stopped VM's
        # Stopped VM's do not allow extensions to be installed
        - task: AzureResourceGroupDeployment@2
          displayName: 'Stop VM''s in resource group'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: Stop
            resourceGroupName: '$(resourceGroup)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        # Test for failures that only occur when resources already exist
        - task: AzureCLI@2
          name: terraform
          displayName: 'Terraform init and apply (re-entrance test)'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # Convert uppercased Terraform environment variables to their original casing expeted by Terraform
              foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
                $upperCaseName = $tfvar.Name + "_UC"
                $properCaseName = $tfvar.Name.Substring(0,7) + $tfvar.Name.Substring(7).ToLowerInvariant()
                $null = New-Item -Path env:$upperCaseName -Value $tfVar.Value
                Remove-Item -Path env:$($tfvar.Name)
                $null = New-Item -Path env:$properCaseName -Value $tfVar.Value
                Set-Item -Path env:$upperCaseName -Value $null
              } 
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              terraform apply -auto-approve
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'

  - ${{ if eq(parameters.deploy, true) }}:
    # Deploy application 
    - job: 'Deploy'
      dependsOn:
        - Prepare
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Deploy Application'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        appArtifactDirectory: '$(Pipeline.Workspace)/aspnetcoresql'
        appBuild: 'Release'
        appPackage: '$(appArtifactDirectory)/s/bin/$(appBuild)/netcoreapp3.1/publish.zip'
        # Get application configuration from Terraform output
        appServiceName: $[ dependencies.Provision.outputs['terraform.paas_app_service_name'] ]
        appMSIName: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_name'] ]
        appMSIClientID: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_client_id'] ]
        appSQLAdmin: 'demoadmin'
        appSQLDatabase: $[ dependencies.Provision.outputs['terraform.paas_app_sql_database'] ]
        appSQLFirewallImportRule: 'AllowAllWindowsAzureIPs'
        appSQLServer: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server'] ]
        appSQLServerFQDN: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server_fqdn'] ]
        appURL: $[ dependencies.Provision.outputs['terraform.paas_app_url'] ]
        devOpsOrgURL: $[ dependencies.Provision.outputs['terraform.devops_org_url'] ]
        devOpsProject: $[ dependencies.Provision.outputs['terraform.devops_project'] ]
        dbaName: $[ dependencies.Provision.outputs['terraform.admin_login'] ]
        dbaObjectID: $[ dependencies.Provision.outputs['terraform.admin_object_id'] ]
        storageUrl: 'https://ewimages.blob.core.windows.net/databasetemplates/vdcdevpaasappsqldb-2020-1-18-15-13.bacpac'
        storageSAS: '?st=2020-03-20T13%3A57%3A32Z&se=2023-04-12T13%3A57%3A00Z&sp=r&sv=2018-03-28&sr=c&sig=qGpAjJlpDQsq2SB6ev27VbwOtgCwh2qu2l3G8kYX4rU%3D'
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

        sqlServerFQDN: $[ dependencies.Provision.outputs['terraform.sql_dwh_fqdn'] ]
        sqlDatabase: $[ dependencies.Provision.outputs['terraform.sql_dwh_pool_name'] ]

      pool:
        # SqlAzureDacpacDeployment@1 only runs on Windows
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Assume workspace is empty and re-download secure files
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform init'
          condition: succeededOrFailed()
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            # ARM_* environment variables are required by Terraform azurerm provider and backend
            # https://www.terraform.io/docs/providers/azurerm/index.html
            # https://www.terraform.io/docs/backends/types/azurerm.html
            # Use Pipeline Service Principal and Service Connection to set up these variables
            inlineScript: |
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,TF_* | Sort-Object -Property Name
              $(scriptDirectory)/tf_deploy.ps1 -init 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(scriptDirectory)'

        - pwsh: |
            Invoke-Webrequest -Uri "$(storageUrl)$(storageSAS)" -OutFile $(System.DefaultWorkingDirectory)/database.bacpac
          displayName: 'Download BACPAC'
          enabled: false

        # Requires a Windows Pipeline agent
        - task: SqlAzureDacpacDeployment@1
          displayName: 'Load New York Taxicab data'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            AuthenticationType: 'aadAuthenticationIntegrated'
            ServerName: '$(sqlServerFQDN)'
            DatabaseName: '$(sqlDatabase)'
            deployType: 'SqlTask'
            SqlFile: '$(scriptDirectory)/load-data.sql'
            IpDetectionMethod: 'AutoDetect'
            # deleteFirewallRule: true

        - task: AzureCLI@2
          displayName: 'Import database, set permissions (with script) & swap App Service slots'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)
              $(scriptDirectory)/punch_hole.ps1 -UsePreviewApis
              cd $(scriptDirectory)
              $(scriptDirectory)/deploy_paas_app.ps1 -All `
                                    -AppResourceGroup $(paasResourceGroup) `
                                    -AppAppServiceName $(appServiceName) `
                                    -AppAppServiceIdentity $(appMSIName) `
                                    -AppAppServiceClientID $(appMSIClientID) `
                                    -DBAName $(dbaName) `
                                    -DBAObjectId $(dbaObjectId) `
                                    -AppUrl $(appURL) `
                                    -DevOpsOrgUrl $(devOpsOrgURL) `
                                    -DevOpsProject $(devOpsProject) `
                                    -SqlServer $(appSQLServer) `
                                    -SqlServerFQDN $(appSQLServerFQDN) `
                                    -SqlDatabase $(appSQLDatabase)
            addSpnToEnvironment: true
            useGlobalConfig: true
            workingDirectory: '$(terraformDirectory)'
            failOnStandardError: true

  - ${{ if eq(parameters.deploy, true) }}:
    # Test applications
    - job: 'Test'
      dependsOn:
        - Deploy
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Test Applications'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        apimGWUrl:     $[ dependencies.Provision.outputs['terraform.apim_gateway_url'] ]
        apimPortalUrl: $[ dependencies.Provision.outputs['terraform.apim_developer_portal_url'] ]
        deployAPIM:    $[ eq(variables['TF_VAR_deploy_api_gateway'], 'true') ]
        iaasAppUrl:    $[ dependencies.Provision.outputs['terraform.iaas_app_url'] ]
        paasAppUrl:    $[ dependencies.Provision.outputs['terraform.paas_app_url'] ]
        # apim_demo_api_key get's updated on every terraform apply, make sure we get up to date data
        ${{ if eq(parameters.reprovision, false) }}:
          apimDemoKey: $[ dependencies.Provision.outputs['terraform.apim_demo_api_key'] ]
        ${{ if eq(parameters.reprovision, true) }}:
          apimDemoKey: $[ dependencies.Reprovision.outputs['terraform.apim_demo_api_key'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Test PaaS Application
        - task: PowerShell@2
          displayName: 'Test PaaS Application'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Wait for the WAF to get ready
              Start-Sleep -Seconds 10
              
              # Request page
              Write-Host "Requesting $(paasAppUrl)..."
              Invoke-WebRequest -Uri $(paasAppUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

        # Test API Management
        - task: PowerShell@2
          displayName: 'Test API Management Portal'
          condition: and(succeeded(), eq(variables.deployAPIM, true))
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Request page
              Write-Host "Requesting $(apimPortalUrl)..."
              Invoke-WebRequest -Uri $(apimPortalUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true
        - task: PowerShell@2
          displayName: 'Test API Management Gateway'
          condition: and(succeeded(), eq(variables.deployAPIM, true))
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Call REST Api
              $apimDemoUrl = "$(apimGWUrl)echo/resource?param1=sample"
              Write-Host "Performing GET request of $apimDemoUrl with Header Ocp-Apim-Subscription-Key = $(apimDemoKey)..."
              Invoke-RestMethod -Header @{ "Ocp-Apim-Subscription-Key" = "$(apimDemoKey)" } -Method Get -Uri $apimDemoUrl -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Destroy infrastructure
    - job: 'Destroy'
      dependsOn:
        - Prepare
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.deploy, true) }}:
          - Deploy
          - Test
      displayName: 'Destroy Infrastructure with Terraform'

      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: succeededOrFailed()
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: failed()
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: succeeded()

      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform destroy'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              terraform destroy -auto-approve
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'

        # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
        - task: PowerShell@2
          displayName: 'Save used Terraform version number with tfenv'
          enabled: false # `${{ not(parameters.testMode) }}
          inputs:
            targetType: filePath
            filePath: '$(scriptDirectory)/get_tf_version.ps1'
            arguments: ' -version installed | Out-File $(terraformDirectory)/.terraform-version'
            pwsh: true
            workingDirectory: '$(scriptDirectory)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
        # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
        # Publish Initialized Terraform workspace
        # This workspace can be downloaded as artifacts in a release pipeline. 
        # That release pipeline will than run with tested versions of Terraform and Terraform providers, without the need for 'terraform init'
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Initialized Terraform workspace'
          # enabled: ${{ not(parameters.testMode) }}
            inputs:
              artifact: $(artifactName)

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Clean up resources, in the event 'terraform destroy' fails   
    - job: 'CleanUp'
      dependsOn:
        - Prepare
        - Destroy
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Clean Up'
      # Run if Terraform destroy failed, or the whole pipeline was canceled
      condition: or(and(ne(dependencies.Destroy.result, 'None'),ne(dependencies.Destroy.result, 'Skipped'),ne(dependencies.Destroy.result, 'Succeeded')), and(canceled(),variables.cleanUpOnCancel))
      #condition: always()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: AzureResourceGroupDeployment@2
          displayName: 'Tear down resource group'
          enabled: false # rely on cleanup
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: DeleteRG
            resourceGroupName: '$(resourceGroup)'
          continueOnError: true
          condition: succeededOrFailed()

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'
          condition: always()

        # Clear Terraform workspace, just in case
        # As a last resort, this also destroys any resources that may not have deleted before
        - task: AzureCLI@2
          name: terraform
          displayName: 'Clear Terraform workspace'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Build JMESPath expression
              $tagQuery = "[?tags.repository == '$(repository)' && tags.workspace == '${env:TF_WORKSPACE}' && tags.runid == '$(Build.BuildId)' && properties.provisioningState != 'Deleting'].id"
              Write-Host "Removing resource group identified by `"$tagQuery`"..."
              $resourceGroupIDs = $(az group list --query "${tagQuery}" -o tsv)

              # Remove resources
              if ($resourceGroupIDs) {
                Write-Host "Removing resource group(s) `"${resourceGroupIDs}`"..."
                &{ # az writes information to stderr
                  $ErrorActionPreference = 'SilentlyContinue'
                  az resource delete --ids $resourceGroupIDs 2>&1
                }
              } else {
                Write-Host "Nothing to remove"
              }

              # Clean up Terraform state
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)

              Copy-Item backend.tf.example backend.tf
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              $terraformState = (terraform state pull | ConvertFrom-Json)
              if ($terraformState.resources) {
                Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
                $terraformState.outputs = New-Object PSObject # Empty output
                $terraformState.resources = @() # No resources
                $terraformState.serial++
                $terraformState | ConvertTo-Json | terraform state push -
              } else {
                Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
              }
              terraform state pull 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'
            