# This pipeline template performs a full CI test:
#  - Provision infrastructure
#  - Deploy application
#  - Test application
#  - Destroy infrastructure
parameters:
- name: name
  displayName: Stage Name
  type: string
- name: displayName
  displayName: Stage Display Name
  type: string
- name: inherit
  displayName: Inherit state
  type: boolean
  default: false
- name: provision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: reprovision
  displayName: Provision infrastructure
  type: boolean
  default: true
- name: deploy
  displayName: Deploy applications
  type: boolean
  default: true
- name: destroy
  displayName: Destroy infrastructure
  type: string
  default: Always
  values:
  - Always
  - Never 
  - 'On failure'
  - 'On success'
- name: workspace
  displayName: Pipeline Environment / Terraform Workspace
  type: string
  default: ci
  values:
  - ci
  - ci1
  - ci2
  - ci3
  - cd1
  - cd2
  - cd3
  - rel
  - rel1
  - rel2
  - rel3
  - test
  - tst1
  - tst2
  - tst3
- name: deploymentName
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: resourceSuffix
  displayName: Deployment name (middle part resource names)
  type: string
  default: ''
- name: unpinTerraform
  displayName: Unpin Terraform version
  type: boolean
  default: false
- name: unpinTerraformProviders
  displayName: Unpin Terraform provider versions
  type: boolean
  default: false
- name: infraArtifactPipeline
  displayName: Pipeline (alias) for artifacts
  type: string
  default: ''
- name: testMode
  displayName: Test Mode (disable most tasks)
  type: boolean
  default: false

stages:
- stage: ${{ parameters.name }}
  displayName: ${{ parameters.displayName }}

  # Global variables shared by all jobs
  variables:
  - name: 'artifactName'
    value: 'drop'
  - name: 'TF_WORKSPACE'
    value: ${{ parameters.workspace }}
  - name: 'scriptDirectory'
    ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/scripts'
    ${{ if and(gt(length(parameters.infraArtifactPipeline),0),ne(parameters.infraArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.infraArtifactPipeline}}/$(artifactName)/s/scripts'
    ${{ if eq(parameters.infraArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(artifactName)/s/scripts'
  - name: 'terraformDirectory'
    ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
      value: '$(Build.SourcesDirectory)/terraform'
    ${{ if and(gt(length(parameters.infraArtifactPipeline),0),ne(parameters.infraArtifactPipeline,'current')) }}:
      value: '$(Pipeline.Workspace)/${{parameters.infraArtifactPipeline}}/$(artifactName)/s/terraform'
    ${{ if eq(parameters.infraArtifactPipeline,'current') }}:
      value: '$(Pipeline.Workspace)/$(artifactName)/s/terraform'
  - ${{ if gt(length(parameters.resourceSuffix),0) }}:
    - name: 'TF_VAR_resource_suffix'
      value: ${{ parameters.resourceSuffix }}
  - name: 'resourceGroup' 
    value: 'synapse-network-$(TF_VAR_resource_suffix)'
  - name: 'terraformVersionRequest'
    ${{ if parameters.unpinTerraform }}:
      value: 'latest'
    ${{ if not(parameters.unpinTerraform) }}:
      value: 'preferred'
  - name: cleanUpOnCancel
    ${{ if eq(parameters.destroy, 'Always') }}:
      value: true
    ${{ if eq(parameters.destroy, 'Never') }}:
      value: false
    ${{ if eq(parameters.destroy, 'On failure') }}:
      value: true
    ${{ if eq(parameters.destroy, 'On success') }}:
      value: false
  - name: vmImage
    # value: 'ubuntu-latest'
    value: 'windows-latest' # SqlAzureDacpacDeployment requires Windows
  - name: rowCount
    value: 3

  jobs:
  - job: 'Prepare'
    displayName: 'Prepare'
    condition: succeeded()
    timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

    pool:
      vmImage: '$(vmImage)'

    workspace:
      clean: all

    steps:
      - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
        - download: ${{parameters.infraArtifactPipeline}}
          artifact: $(artifactName)
  
      - pwsh: |
          Write-Host "Script Directory: $(scriptDirectory)"
          Write-Host "Workspace Contents:"
          Get-ChildItem $(Pipeline.Workspace) -Recurse
          Write-Host "Environment:"
          Get-ChildItem -Path Env:* | Sort-Object -Property Name
        displayName: 'Test task'
        enabled: ${{ parameters.testMode }}
      - task: AzureCLI@2
        displayName: 'Gather Terraform settings'
        enabled: ${{ not(parameters.testMode) }}
        name: terraformConfig
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            # List environment variables
            Get-ChildItem -Path Env: -Recurse -Include ARM_*,TF_* | Sort-Object -Property Name

            $terraformVersion = (Get-Content .terraform-version)
            Write-Host "##vso[task.setvariable variable=version;isOutput=true]${terraformVersion}"
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'

  - ${{ if or(eq(parameters.provision, true),eq(parameters.reprovision, true),eq(parameters.deploy, true)) }}:
    # Provision on self-hosted agent
    - job: 'Provision'
      dependsOn: 
      - Prepare
      # - CreateEnvironment
      displayName: 'Provision Infrastructure with Terraform'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # We could do this with tfenv, however there is no task for that
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              #(Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          displayName: 'Terraform init'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          displayName: 'Terraform plan'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # Convert uppercased Terraform environment variables to their original casing expeted by Terraform
              foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
                $upperCaseName = $tfvar.Name + "_UC"
                $properCaseName = $tfvar.Name.Substring(0,7) + $tfvar.Name.Substring(7).ToLowerInvariant()
                $null = New-Item -Path env:$upperCaseName -Value $tfVar.Value
                Remove-Item -Path env:$($tfvar.Name)
                $null = New-Item -Path env:$properCaseName -Value $tfVar.Value
                Set-Item -Path env:$upperCaseName -Value $null
              } 
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              # Run Terraform
              terraform version
              terraform plan -out='ci.tfplan'
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          displayName: 'Terraform apply'
          name: terraform
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

              # Run Terraform
              terraform version
              terraform apply -auto-approve 'ci.tfplan'

              # Export Terraform output as task output
              $json = terraform output -json | ConvertFrom-Json -AsHashtable
              foreach ($outputVariable in $json.keys) {
                  $value = $json[$outputVariable].value
                  if ($value) {
                      Write-Host "##vso[task.setvariable variable=$outputVariable;isOutput=true]$value"
                  }
              }              
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            powerShellIgnoreLASTEXITCODE: false
            workingDirectory: '$(terraformDirectory)'

  - ${{ if eq(parameters.reprovision, true) }}:
    # Provision again to test for issue's that only come up when resources already exist 
    - job: 'Reprovision'
      dependsOn:
      - Prepare
      - Provision
      displayName: 'Provision Infrastructure with Terraform (re-entrance test)'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        resourceGroup: $[ dependencies.Provision.outputs['terraform.resource_group_name'] ]
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +",'version = "~> ' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        # Deallocate/Stop MV's to force tf_deploy.ps1 to test for stopped VM's
        # Stopped VM's do not allow extensions to be installed
        - task: AzureResourceGroupDeployment@2
          displayName: 'Stop VM''s in resource group'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: Deallocate
            resourceGroupName: '$(resourceGroup)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        # Test for failures that only occur when resources already exist
        - task: AzureCLI@2
          name: terraform
          displayName: 'Terraform init and apply (re-entrance test)'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              
              
              # Convert uppercased Terraform environment variables to their original casing expeted by Terraform
              foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
                $upperCaseName = $tfvar.Name + "_UC"
                $properCaseName = $tfvar.Name.Substring(0,7) + $tfvar.Name.Substring(7).ToLowerInvariant()
                $null = New-Item -Path env:$upperCaseName -Value $tfVar.Value
                Remove-Item -Path env:$($tfvar.Name)
                $null = New-Item -Path env:$properCaseName -Value $tfVar.Value
                Set-Item -Path env:$upperCaseName -Value $null
              } 
              # List environment variables
              Get-ChildItem -Path Env: -Recurse -Include ARM_*,AZURE_*,TF_* | Sort-Object -Property Name

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              terraform apply -auto-approve
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'

  - ${{ if eq(parameters.deploy, true) }}:
    # Deploy application 
    - job: 'Deploy'
      dependsOn:
        - Prepare
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Deploy Application'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        appArtifactDirectory: '$(Pipeline.Workspace)/aspnetcoresql'

        # appBuild: 'Release'
        # appPackage: '$(appArtifactDirectory)/s/bin/$(appBuild)/netcoreapp3.1/publish.zip'
        # # Get application configuration from Terraform output
        # appServiceName: $[ dependencies.Provision.outputs['terraform.paas_app_service_name'] ]
        # appMSIName: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_name'] ]
        # appMSIClientID: $[ dependencies.Provision.outputs['terraform.paas_app_service_msi_client_id'] ]
        # # appSQLAdmin: 'demoadmin'
        # appSQLDatabase: $[ dependencies.Provision.outputs['terraform.paas_app_sql_database'] ]
        # appSQLFirewallImportRule: 'AllowAllWindowsAzureIPs'
        # appSQLServer: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server'] ]
        # appSQLServerFQDN: $[ dependencies.Provision.outputs['terraform.paas_app_sql_server_fqdn'] ]
        # appURL: $[ dependencies.Provision.outputs['terraform.paas_app_url'] ]
        # devOpsOrgURL: $[ dependencies.Provision.outputs['terraform.devops_org_url'] ]
        # devOpsProject: $[ dependencies.Provision.outputs['terraform.devops_project'] ]
        # dbaName: $[ dependencies.Provision.outputs['terraform.admin_login'] ]
        # dbaObjectID: $[ dependencies.Provision.outputs['terraform.admin_object_id'] ]
        # storageUrl: 'https://ewimages.blob.core.windows.net/databasetemplates/vdcdevpaasappsqldb-2020-1-18-15-13.bacpac'
        # storageSAS: '?st=2020-03-20T13%3A57%3A32Z&se=2023-04-12T13%3A57%3A00Z&sp=r&sv=2018-03-28&sr=c&sig=qGpAjJlpDQsq2SB6ev27VbwOtgCwh2qu2l3G8kYX4rU%3D'

        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]
        functionsDirectory: '$(Build.SourcesDirectory)/functions'
        functionName: $[ dependencies.Provision.outputs['terraform.function_name'] ]

        adminUser: $[ dependencies.Provision.outputs['terraform.user_name'] ]
        adminPassword: $[ dependencies.Provision.outputs['terraform.user_password'] ]
        sqlServerFQDN: $[ dependencies.Provision.outputs['terraform.sql_dwh_fqdn'] ]
        sqlDatabase: $[ dependencies.Provision.outputs['terraform.sql_dwh_pool_name'] ]

      pool:
        # SqlAzureDacpacDeployment@1 only runs on Windows
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Assume workspace is empty and re-download secure files
        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform init'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)"
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'

        - task: DotNetCoreCLI@2
          displayName: 'Restore function(s) dependencies'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            command: 'restore'
            projects: '**/*.csproj'
            workingDirectory: '$(functionsDirectory)'

        - task: DotNetCoreCLI@2
          displayName: 'Build function(s) ($(buildConfiguration))'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            command: 'build'
            arguments: '--configuration $(buildConfiguration) --no-restore'
            workingDirectory: '$(functionsDirectory)'

        - task: DotNetCoreCLI@2
          displayName: 'Publish function(s) artifacts ($(buildConfiguration))'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            command: publish
            publishWebProjects: False
            arguments: '--configuration $(BuildConfiguration) --output $(Build.ArtifactStagingDirectory)'
            workingDirectory: '$(functionsDirectory)'
            zipAfterPublish: True

        - task: AzureFunctionApp@1
          displayName: 'Deploy Azure function(s)'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            appType: functionAppLinux
            appName: '$(functionName)'
            package: $(System.ArtifactsDirectory)/**/*.zip

        # # This task requires a Windows Pipeline agent, and is hard to debug
        # - task: SqlAzureDacpacDeployment@1
        #   displayName: 'Load New York Taxicab data'
        #   enabled: false # ${{ not(parameters.testMode) }}
        #   inputs:
        #     azureSubscription: '$(subscriptionConnection)'
        #     AuthenticationType: 'aadAuthenticationIntegrated'
        #     ServerName: '$(sqlServerFQDN)'
        #     DatabaseName: '$(sqlDatabase)'
        #     deployType: 'SqlTask'
        #     SqlFile: '$(scriptDirectory)/load-data.sql'
        #     IpDetectionMethod: 'AutoDetect'
        #     # deleteFirewallRule: true

        - task: AzureCLI@2
          displayName: 'Load New York Taxicab data'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)
              ./load_data.ps1 -ResourceGroup $(resourceGroup) `
                              -SqlServerFQDN $(sqlServerFQDN) `
                              -SqlDatabaseName $(sqlDatabase) `
                              -UserName $(adminUser)`
                              -Password "$(adminPassword)"
            addSpnToEnvironment: true
            useGlobalConfig: true
            workingDirectory: '$(scriptDirectory)'
            failOnStandardError: true

        # - task: AzureCLI@2
        #   displayName: 'Retrieve top $(rowCount) rows'
        #   enabled: ${{ not(parameters.testMode) }}
        #   inputs:
        #     azureSubscription: '$(subscriptionConnection)'
        #     scriptType: pscore
        #     scriptLocation: inlineScript
        #     inlineScript: |
        #       $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
        #       $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
        #       $env:ARM_TENANT_ID       ??= $env:tenantId
        #       $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
        #       $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)

        #       $securePassword =  ConvertTo-SecureString -String "$(adminPassword)" -AsPlainText
        #       ./run_query.ps1 -ResourceGroup $(resourceGroup) `
        #                       -SqlServerFQDN $(sqlServerFQDN) `
        #                       -SqlDatabaseName $(sqlDatabase) `
        #                       -SqlUser $(adminUser)`
        #                       -SecurePassword $securePassword `
        #                       -RowCount $(rowCount)
        #     addSpnToEnvironment: true
        #     useGlobalConfig: true
        #     workingDirectory: '$(scriptDirectory)'
        #     failOnStandardError: true

  - ${{ if eq(parameters.deploy, true) }}:
    # Test applications
    - job: 'Test'
      dependsOn:
        - Deploy
        - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Test Applications'
      condition: succeeded()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        sqlServerFQDN: $[ dependencies.Provision.outputs['terraform.sql_dwh_fqdn'] ]
        sqlDatabase: $[ dependencies.Provision.outputs['terraform.sql_dwh_pool_name'] ]
        adminUser: $[ dependencies.Provision.outputs['terraform.user_name'] ]
        adminPassword: $[ dependencies.Provision.outputs['terraform.user_password'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        # Test PaaS Application
        - task: PowerShell@2
          displayName: 'Test PaaS Application'
          enabled: false # ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              # Wait for the WAF to get ready
              Start-Sleep -Seconds 10
              
              # Request page
              Write-Host "Requesting $(paasAppUrl)..."
              Invoke-WebRequest -Uri $(paasAppUrl) -MaximumRetryCount 9
            failOnStderr: true
            pwsh: true

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Destroy infrastructure
    - job: 'Destroy'
      dependsOn:
        - Prepare
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.deploy, true) }}:
          - Deploy
          - Test
      displayName: 'Destroy Infrastructure with Terraform'

      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: succeededOrFailed()
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: failed()
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: succeeded()

      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
          # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
          - pwsh: |
              (Get-Content ./provider.tf) -replace "version *= `" *= +(?<eol>[^,]+$)",'version = "~> ${eol}' | Out-File provider.tf
              Get-Content ./provider.tf
            displayName: 'Unpin Terraform provider version'
            enabled: ${{ and(not(parameters.testMode),parameters.unpinTerraformProviders) }}
            workingDirectory: '$(terraformDirectory)'

        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - bash: |
              find . -name *_x?
              find . -name *_x? | xargs chmod +x
            displayName: 'Make Terraform providers executable'
            enabled: ${{ not(parameters.testMode) }}
            workingDirectory: $(terraformDirectory)/.terraform/providers/registry.terraform.io/hashicorp 

        - task: AzureCLI@2
          name: terraformConfig
          displayName: 'Terraform destroy'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)              

              Copy-Item backend.tf.example backend.tf
              # Run Terraform
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              terraform destroy -auto-approve
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'

        # When using tfenv, this will make sure the same Terraform version will be used as we tested in this pipeline
        - task: PowerShell@2
          displayName: 'Save used Terraform version number'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            targetType: 'inline'
            script: |
              $result = (terraform -v | Select-String -Pattern '(?<version>[\d\.]+)')
              $result.Matches[0].Groups['version'].Value | Out-File -FilePath .terraform-version -Force
            pwsh: true
            workingDirectory: '$(terraformDirectory)'

        - ${{ if eq(length(parameters.infraArtifactPipeline),0) }}:
        # Unpin version e.g. "= 2.17" -> "~> 2.17", but only in CI build
        # Publish Initialized Terraform workspace
        # This workspace can be downloaded as artifacts in a release pipeline. 
        # That release pipeline will than run with tested versions of Terraform and Terraform providers, without the need for 'terraform init'
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Initialized Terraform workspace'
          # enabled: ${{ not(parameters.testMode) }}
            inputs:
              artifact: $(artifactName)

  - ${{ if ne(parameters.destroy, 'Never') }}:
    # Clean up resources, in the event 'terraform destroy' fails   
    - job: 'CleanUp'
      dependsOn:
        - Prepare
        - Destroy
        - ${{ if or(eq(parameters.provision, true),eq(parameters.deploy, true)) }}:
          - Provision
        - ${{ if eq(parameters.reprovision, true) }}:
          - Reprovision
      displayName: 'Clean Up'
      # Run if Terraform destroy failed, or the whole pipeline was canceled
      condition: or(and(ne(dependencies.Destroy.result, 'None'),ne(dependencies.Destroy.result, 'Skipped'),ne(dependencies.Destroy.result, 'Succeeded')), and(canceled(),variables.cleanUpOnCancel))
      #condition: always()
      timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

      variables:
        # Use earlier prepared Terraform config
        terraformVersion: $[ dependencies.Prepare.outputs['terraformConfig.version'] ]

      pool:
        vmImage: '$(vmImage)'

      workspace:
        clean: all

      steps:
        - ${{ if gt(length(parameters.infraArtifactPipeline),0) }}:
          - download: ${{parameters.infraArtifactPipeline}}
            artifact: $(artifactName)
    
        - pwsh: |
            Write-Host "Hello Task"
          displayName: 'Test task'
          enabled: ${{ parameters.testMode }}

        - task: AzureResourceGroupDeployment@2
          displayName: 'Tear down resource group'
          enabled: false # rely on cleanup
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            action: DeleteRG
            resourceGroupName: '$(resourceGroup)'
          continueOnError: true
          condition: succeededOrFailed()

        - task: TerraformInstaller@0
          displayName: 'Use preferred Terraform version'
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            terraformVersion: '$(terraformVersion)'
          condition: always()

        # Clear Terraform workspace, just in case
        # As a last resort, this also destroys any resources that may not have deleted before
        - task: AzureCLI@2
          name: cleanup
          displayName: 'Destroy remaining resources & Clear Terraform workspace'
          condition: succeededOrFailed()
          enabled: ${{ not(parameters.testMode) }}
          inputs:
            azureSubscription: '$(subscriptionConnection)'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $ErrorActionPreference = "Continue"

              # Build JMESPath expression
              $tagQuery = "[?tags.repository == '$(repository)' && tags.workspace == '${env:TF_WORKSPACE}' && tags.runid == '$(Build.BuildId)' && properties.provisioningState != 'Deleting'].id"
              Write-Host "Removing resource group identified by `"$tagQuery`"..."
              $resourceGroupIDs = $(az group list --query "${tagQuery}" -o tsv)

              # Remove resources
              if ($resourceGroupIDs) {
                Write-Host "Removing resource group(s) `"${resourceGroupIDs}`"..."
                &{ # az writes information to stderr
                  $ErrorActionPreference = 'SilentlyContinue'
                  az resource delete --ids $resourceGroupIDs 2>&1
                }
              } else {
                Write-Host "Nothing to remove"
              }

              # Clean up Terraform state
              # Propagate pipeline Service Principal as Terraform variables
              $env:ARM_CLIENT_ID       ??= $env:servicePrincipalId
              $env:ARM_CLIENT_SECRET   ??= $env:servicePrincipalKey
              $env:ARM_TENANT_ID       ??= $env:tenantId
              # Get from Azure CLI context
              $env:ARM_TENANT_ID       ??= $(az account show --query tenantId -o tsv)
              $env:ARM_SUBSCRIPTION_ID ??= $(az account show --query id -o tsv)

              Copy-Item backend.tf.example backend.tf
              terraform version
              terraform init -reconfigure `
                             -backend-config="resource_group_name=$(TF_STATE_RESOURCE_GROUP_NAME)" `
                             -backend-config="storage_account_name=$(TF_STATE_STORAGE_ACCOUNT_NAME)" `
                             -backend-config="container_name=$(TF_STATE_CONTAINER_NAME)" 
              $terraformState = (terraform state pull | ConvertFrom-Json)
              if ($terraformState.resources) {
                Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
                $terraformState.outputs = New-Object PSObject # Empty output
                $terraformState.resources = @() # No resources
                $terraformState.serial++
                $terraformState | ConvertTo-Json | terraform state push -
              } else {
                Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
              }
              terraform state pull 
            addSpnToEnvironment: true
            useGlobalConfig: true
            failOnStandardError: true
            workingDirectory: '$(terraformDirectory)'
            